\documentclass{article}
\usepackage[top=1cm, bottom=1.5cm, left=1.5cm, right=1.5cm]{geometry}
\usepackage[ansinew]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{pgf}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{amssymb}
\usetikzlibrary{arrows,automata}


\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{1,0,0}


\lstset{ %
  backgroundcolor=\color{white},   % choose the background color
  basicstyle=\footnotesize,        % size of fonts used for the code
  breaklines=true,                 % automatic line breaking only at whitespace
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  keywordstyle=\color{blue},       % keyword style
  stringstyle=\color{mymauve},     % string literal style
	numbers=left,
	frame=leftline,
	xleftmargin=42pt
}

\title{%
    \begin{minipage}\linewidth
        \centering \bfseries
        \vspace{8cm}
        Rapport du projet de cryptographie
        \vspace{1cm}
        \vskip3pt
        \large Modélisation Mathématiques
        \vspace{1cm}
    \end{minipage}
}
\date{12 décembre 2016}
\author{Mathis Deloge, Antoine Petot, Ange Picard}



\begin{document}

% définition des style de puces
\renewcommand{\labelitemi}{$\bullet$}
\renewcommand{\labelitemii}{$\circ$}
\renewcommand{\labelitemiii}{$-$}
\renewcommand{\labelitemiv}{$\triangleright$}



\maketitle
\newpage
\section{Descriptif du sujet}
Nous étudierons ici deux algorithmes bien connus en cryptographie, l’échange de clé de Diffie-Hellman et le chiffrement par transposition. Pour illustrer nos propos, nous ferons appel à Alice et Bob, deux personnages voulant s’échanger une clé de cryptage afin de s’échanger des messages sécurisés sans que personne ne puisse les intercepter. Nous les conseillerons tout d’abord sur le choix du protocole leur permettant de partager une clé de chiffrement puis nous argumenterons l’utilisation de chacun des protocoles, les modèles mathématiques sur lesquels ils se basent, ainsi que leurs failles.

Différents prolongements nous permettrons d’étudier plus précisément ces protocoles de cryptographie, notamment le problème du logarithme discret ainsi que l’algorithme ``baby step giant step'' permettant de s’approcher de la résolution de ce problème.



\subsection{Diffie-Hellman}
Diffie-Hellman est un protocole d'échange de clé créé par Whitfield Diffie et Martin Hellman après leur découverte du principe de la cryptographie à clé publique.
Il permet notamment à deux personnes (ici, Alice et Bob) de s'échanger une clé de chiffrement (un nombre entier)  en choisissant publiquement un groupe fini G 
et un générateur g de ce groupe sans qu'un possible espion (Eve) ne puisse déterminer cette clé.

Le principe de ce protocole est assez simple :
\begin{itemize}
 \item Alice et Bob choisissent un nombre premier p et un nombre entier a tel que $1\leq a \leq p-1$.
 \item Alice choisit secrètement un nombre entier $x_1$ et Bob fait de même avec $x_2$.
 \item Alice calcule alors $y^1 = a^{(x_1)}$ (mod p) et Bob fait de même avec $y^2 = a^{(x_2)}$ (mod p).
 \item Alice et Bob s'échangent publiquement les valeurs de $y_1$ et $y_2$.
 \item Alice calcule $y_2^{x_1} = (a^{x_2})^{x_1} = a^{x_1 x_2}$ (mod p) et obtient $K$, la clé secrète.
 \item Bob calcule $y_1^{x_2} = (a^{x_1})^{x_2} = a^{x_1 x_2}$ (mod p) et obtient la même clé $K$ que Alice.
\end{itemize}

\begin{figure}[!h]
  \center
  \includegraphics[width=6.4cm]{Images/Diffie-Hellman.png}
  \caption{Représentation Diffie-Hellman}
\end{figure}

\vspace{0.5cm}
D'après le problème du logarithme discret, Eve ne peut pas déterminer $K$ en ayant connaissance de $p$, $a$, $y_1$ et $y_2$.
Ainsi, Alice et Bob peuvent s'échanger en toute sécurité une clé de chiffrement $K$ mise à part s'ils sont victimes d'une attaque dite de ``l'homme du milieu'' par Eve.

\subsection{Chiffrement par transposition}
Le chiffrement par transposition est un protocole d'échange de messages cryptés basée sur une méthode simple : permuter l'ordre des lettres du message suivant certaines règles.

Dans notre cas, nous allons ainsi créer une anagramme du message initial en respectant ces conditions en s'aidant d'un tableau :
\begin{itemize}
 \item Pour commencer, nous allons créer un tableau de la largeur de la clé de chiffrement
 \item Nous écrirons ensuite caractère par caractère et ligne après ligne le message à coder
 \item Il suffit alors d'organiser les colonnes suivant l'ordre croissant des caractères de la clé de chiffrement
 \item Pour écrire le message chiffré, nous allons alors lire le tableau colonne par colonne en créant des mots de tailles similaires
 \item Afin de déchiffrer le message, il suffit de reprendre ces étapes à l'envers
\end{itemize}

\vspace{0.5cm}

\begin{figure}[!h]
  \center
  \includegraphics[width=15cm]{Images/tableau.jpg}
  \caption{Exemple de transposition}
\end{figure}

\vspace{0.5cm}
Ce genre de chiffrement est très rudimentaire et peut facilement être craqué à l'aide d'études statistiques d'apparition de lettres dans le message codé pour définir la langue.
Par la suite, on pourra déterminer la longueur de la clé et ainsi découper chaque mot pour essayer de trouver des anagrammes de chaque mot en utilisant un dictionnaire dans la langue déterminée auparavant.


%\newpage

\section{Journal de bord}
\subsection{Séance 1}
Lors de la première séance, notre choix s'est immédiatement tourné vers le sujet de cryptographie qui nous intéressait tout particulièrement.
Après avoir pris connaissance du sujet, nous avons immédiatement entamé les recherches concernant l'échange de clé de Diffie-Hellman afin de comprendre son principe et commencer un début d'implémentation simple en java. Les premières recherches portèrent notament sur le choix des paramètres à choisir pour l'échange de clef.

Nous avons pu poser quelques questions relatives au sujet afin de bien le comprendre et orienter nos travaux dans ce sens.

\subsection{Séance 2}
Durant cette séance, nous avons principalement continué nos recherches toujours axées sur l'échange de clé de Diffie-Hellman mais également sur le chiffrement par transposition. La traduction de celui-ci en algorithme n'as pas été aussi aisée que prévu, la plupart des textes l'expliquant pour le faire à la main et non de manière informatique.
Un début de compte-rendu à commencé à être rédigé ainsi que le projet java final avec lequel les programmes seront implémentés a été créé.

\subsection{Séance 3}
Pendant cette séance, nous nous sommes penchés sur le problème de l'attaque de l'homme du milieu. Après quelques recherches, nous avons pu commencer son implémentation basique et ainsi répondre au prolongement n°3. En vue de la simplicité de l'attaque nous nous sommes aussi documenté sur les différentes manières de contrer celle-ci, comme SSL ou son succésseur TLS et les normes utilisées en web pour le protocole HTTPS. 


\subsection{Séance 4}
Lors de cette dernière séance, nous avons principalement recherché des informations à propos du problème du logarithme discret, son principe et son lien avec la méthode de Diffie-Hellman. Nous avons collecté des informations sur l'algorithme baby step giant step, mais aussi d'autres alternatives commes l'algorithme du rho de Pollard. 


\subsection{Hors séance}
Si nous avons principalement fait des recherches sur les sujets de cryptographie durant les quatre séances de modélisation, la plupart du code à été fait en dehors des séances en s'appuyant sur nos travaux déjà réalisés..

Ce sujet a la particularité par rapport au sujet de la première phase de modélisation que nous avions choisi d'être beaucoup moins exigeants en terme d'implémentation.
En effet, étant donné que les algorithmes de cryptographie existent déjà, le travail que nous avons eu s'est résumé à les comprendre et traduire ces algorithmes en java.


%\newpage

\section{Implémentation}
\subsection{Protocoles}
Lors de l'implémentation de l'algorithme de Diffi-Hellman, nous avons eu différents choix à faire, notamment une base $g$ ainsi qu'un nombre premier $p$.

\vspace{0.5cm}

Dans notre cas, nous avons pris $g = 2$, en effet, même si celui-ci n'est pas nécéssairement générateur dans Z/nZ , il permet de générer un nombre de valeurs bien assez grand dans Z/nZ pour assurer la pérennité de la clé de chiffrement.

\vspace{0.5cm}

Pour choisir un nombre premier $p$, étant donné la difficulté de recherche de très grands nombres premiers, nous avons donc dû utiliser la méthode probablePrime de la classe BigInteger de java. Celle-ci utilise un test de primalité probabiliste renvoyant un nombre premier ou proche d'un nombre premier.
C'est-à-dire un nombre dont la décomposition en facteur premier serait faible ce qui n'est pas gênant dans notre cas puisque pour présenter une réelle faille de sécurité, il faudrait le découpage en facteur premier de $p$ soit très grand.

\vspace{0.5cm}

\begin{figure}[!h]
\begin{lstlisting}[language=java]
import java.math.BigInteger;
import java.security.SecureRandom;

public class PerfectGenerator {
    private BigInteger g;
    private BigInteger p;

    public PerfectGenerator() {
	g = BigInteger.valueOf(2);
	p = BigInteger.probablePrime(2048, new SecureRandom());
    }
}
\end{lstlisting}
\caption{Implémentation de PerfectGenerator}
\end{figure}

\subsection{Attaque de l'homme du milieu}
\subsubsection{Problème}

L'attaque de l'homme du milieu est une attaque dans laquelle une espionne, Eve, essaye d'écouter les communications d'Alice et Bob en leur faisant croire qu'ils sont directement en relation alors qu'en réalité, Alice communique avec Eve qui retransmet les messages à Bob et inversement pour Bob, il croit communiquer directement avec Alice alors qu'en fait, il parle à Eve qui retransmet à Alice. Eve doit donc décrypter ce qu'elle reçoit, elle peut ensuite lire le message en clair avant de le renvoyer à la bonne personne en le ré-encryptant.

\begin{figure}[!h]
  \center
  \includegraphics[width=10cm]{Images/MIM.JPG}
  \caption{Attaque de l'homme du milieu}
\end{figure}

Il est important de préciser que la mise en place de cette technique dans un réseau est souvent facile notamment grâce au spoofing ARP (Eve devient une passerelle du réseau) ou l'ARP poisoning (Eve se fait passer pour le PC d'Alice ou bob en modifiant les informations DNS).

\subsubsection{Solution}

La solution la plus utilisée pour éviter cette attaque est le protocole TLS (anciennement SSL). L'idée est d'introduire une quatrième personne qui sera chargée d'authentifier les identités des personnes qui essayes de communiquer en les certifiant.
Plus précisément, prenons le cas où Alice essaye de communiquer avec Bob :
\begin{itemize}
	\item Bob demande à établir un certificat avec l’autorité de certification
	\item l’autorité de certification vérifie l'identité de Bob et met à jour ses bases de données (et celles de ses clients : Alice)
	\item Alice demande à bob d'ouvrir une communication sécurisée
	\item Bob envoi à Alice son certificat avec sa clé publique et sa signature
	\item Alice essaye de déchiffrer la signature du certificat de bob en utilisant les clés publiques dans sa base de clé locales (que lui a transmis l’autorité de certification). Si une clé réussis à déchiffrer le certificat Alice vérifie auprès de l’autorité de certification qu'il est toujours valide
	\item Alice renvoie à Bob une clé de chiffrement symétrique qu'elle chiffre avec la clé publique que lui a envoyé Bob
	\item Bob déchiffre cette clé avec sa clé privée et utilise la clé de chiffrement symétrique générée par Alice pour crypter toutes les communications qu'il aura avec elle.
	\item Well Done ! La communication TLS est établie
\end{itemize}

\vspace{0.5cm}

Malheureusement si Alice ne fait pas attention, il peut rester une faille... En effet, lorsque Alice essaye de déchiffrer le certificat de bob si aucune clé ne correspond dans sa base de certificat mais qu'elle y arrive quand même cela veut dire que Bob (ou Eve...) essaye de se certifier lui-même. La plupart des navigateurs affichent donc un message de mise en garde. On ne peut donc que conseiller à Alice, dans ce cas, de mettre fin à la tentative de connexion.


%\newpage

\section{Modèle mathématique}
\subsection{Le problème du logarithme discret}
Le principal modèle mathématique auquel nous avons été confrontés pour ce sujet est le problème du logarithme discret, base sur laquelle se construit l'échange de clé de Diffie-Hellman.
Il s'avère que nous sommes actuellement incapables de le résoudre et c'est la raison pour laquelle il est largement utilisé en cryptographie à clé publique.

Après avoir étudié son fonctionnement, son principe repose sur le fait qu'il est impossible pour le moment de déterminer un entier $l$ pour lequel $l = log_g y$ avec $g$ étant un générateur d'une groupe cyclique $G$ et $y \in G$.
C'est essentiellement du au fait que le groupe $G$ choisi est un groupe cyclique et que $log_g y$ soit modulo $n$, $n$ étant l'ordre du groupe $G$ qu'aucune solution ne permette pour l'instant de résoudre ce problème.


\subsection{Baby step giant step}
Cet algorithme est une des solutions envisageables pour approcher la résolution du problème du logarithme discret. Avec celui-ci, d'autres algorithmes tels que le Rho de Pollard qui permet de décomposer en produit des nombres premier et l'algorithme de Pohlig-Hellman qui divise le problème du logarithme discret en autres problèmes de logarithme discret plus petits jusqu'à construire une solution.
Le principe de l'algorithme baby step giant step est de résoudre le problème du logarithme discret en effectuant au maximum $2\sqrt{n}$ multiplications dans le groupe $G$.

\vspace{0.5cm}

On a $p$ est un nombre entier premier. 

On cherche alors le logarithme discret pour $h$.

On pose alors $x = logDiscret(h) = m*q+r$ avec $q$ et $r$ sont des nombres entiers.

On sait également que $0 \leq r < m$ et $m = \lceil \sqrt{n} \rceil$.

\vspace{0.5cm}

On obtient l'équation $g^x = g^{mq}g^r$ mod $p$ avec laquelle on peut caluler les pas de géants : 

$g^i$ pour i allant de 0 à $m-1$ et on stocke la valeur du résultat dans un tableu associatif avec la clé i.

\vspace{0.5cm}

Une fois le tableau associatif des pas de géants remplis, nous pouvons initialiser $q$ à 0 et calculer les pas de bébés suivant cette équation : $h(g^{-m})^q$ en prenant attention d'incrémenter $q$ à chaque calcul.
A chaque résultat obtenu, nous le comparons au tableau associatif des pas de géant. Dès qu'il y a égalité, on arrête les calculs et on obtients $logDiscret(h) = q*m+1$ pour les dernières valeurs de $q$ et $m$.

Bien que cette méthode permette de réduire à environ $2\sqrt{n}$ multiplications comparée à la recherche exhaustive de solution, on peut cependant préciser que $\sqrt{n}$ reste exponentiel.

Dans la pratique, l'utilisation de l'algorithme baby step giant step reste limité puisqu'il convient de trier le tableau des pas de géant et demande un espace mémoire permettant de charger un tableau de taille $\sqrt{n}$ environ.
Autant dire que cela le rend inutilisable assez rapidement. C'est ici que nous pourrons proposer l'utilisation de l'algorithme de Rho de Pollard qui permet la résolution du problème du logarithme discret avec $\sqrt{n}$ multiplications et sans espace mémoire en utilisant le principe du paradoxe des anniversaires.


%\newpage

\section{Conclusion}
\subsection{Les difficultés rencontrées}
Tout au long de ce sujet, nous nous sommes rendu compte assez rapidement que dans le domaine de la cryptographie, la plus grande difficulté réside notamment dans le respect des différents modèles mathématiques lors de l'implémentation.
En effet, tout manquement à quelques règles que ce soit peut engendrer des failles de sécurité et ne pas assurer la transmission de messages privés correctement.

Nous avons ainsi du ``traduire'' correctement chacun des algorithme utilisés afin de respecter les modèles mathématiques sur lesquels ils sont basés et grâce auxquels ils permettent la sécurité des données.
Même si la compréhension des protocoles peut paraître intuitive, on s'aperçoit très vite que les outils mathématiques sur lesquels ils sont basés peuvent être très complexes, notament pour l'algorithme de baby-step giant-step basé sur le problème du logarithme discret.

Concernant le chiffrement par transposition, son implémentation à été assez longue puisque la seule documentation trouvée explique son principe de fonctionnement dans le cadre d'une utilisation ``à la main''.

\subsection{Les outils acquis}
Une vision globale plus précise du domaine de la cryptographie à clé publique, notamment concernant l'échange d'une clé de chiffrement grâce au protocole asymétrique de Diffie-Hellman.
Nous avons découvert qu'il nous est impossible avec les moyens actuels de générer des très grands nombres entiers premiers. C'est pourquoi nous utilisons des tests probabilistes dans le but de générer des nombres entiers très probablement premiers.
Dans l'étude du problème du logarithme discret, nous avons pu aborder l'algorithme baby-step giant-step et son utilisation.

Nous avons ainsi pris conscience des difficultés mathématiques liées au domaine de la cryptographie.
Nous avons pu aborder les différents protocoles utilisés pour sécuriser les communications sur internet (HTTPS).



\newpage
\renewcommand{\contentsname}{Sommaire}
\tableofcontents
\end{document}